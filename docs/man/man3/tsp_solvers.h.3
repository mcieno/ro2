.TH "include/tsp_solvers.h" 3 "Wed May 27 2020" "TSP Solver" \" -*- nroff -*-
.ad l
.nh
.SH NAME
include/tsp_solvers.h \- Methods for solving a TSP problem\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <cplex\&.h>\fP
.br
\fC#include 'tsp\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBTSP_SOLVER_Random\fP   1U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_Dummy\fP   2U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_MTZ\fP   3U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_Flow1\fP   4U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_LazyMTZ\fP   5U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_LazyFlow1\fP   6U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_Loop\fP   7U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_LoopF\fP   8U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_LoopM\fP   9U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_LoopX\fP   10U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_Legacy\fP   11U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_Generic\fP   12U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_LegacyConcorde\fP   13U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_GenericConcorde\fP   14U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_LegacyConcordeShallow\fP   15U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_GenericConcordeShallow\fP   16U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_LegacyConcordeRand\fP   17U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_GenericConcordeRand\fP   18U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_GenericConcordeRandWithPatching\fP   19U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_HeurHardfix\fP   20U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_HeurLocalBranching\fP   21U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_HeurNearestNeighbor\fP   22U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_HeurGRASP\fP   23U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_HeurInsertion\fP   24U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_HeurConvHullInsertion\fP   25U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_HeurGRASPWith2OPTRefinement\fP   26U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_HeurVNS\fP   27U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_HeurTabuSearch\fP   28U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_HeurSimulatedAnnealing\fP   29U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_HeurGenetic\fP   30U"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef unsigned \fBmodel_t\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fB_xopt2solution\fP (const double *xopt, \fBinstance\fP *problem, size_t(*pos)(size_t, size_t, const \fBinstance\fP *))"
.br
.RI "Retrieve the solution after CPXmimopt was run\&. "
.ti -1c
.RI "void \fB_xopt2subtours\fP (const \fBinstance\fP *problem, const double *xopt, size_t *next, size_t *comps, size_t *ncomps, size_t(*pos)(size_t, size_t, const \fBinstance\fP *))"
.br
.RI "Given a CPLEX-generated solution, create a more convenient representation\&. "
.ti -1c
.RI "void \fBRandom_model\fP (\fBinstance\fP *problem)"
.br
.RI "Generate a Random solution for the instance\&. "
.ti -1c
.RI "void \fBDummy_model\fP (\fBinstance\fP *problem)"
.br
.RI "Solve with degree constraints-only model\&. "
.ti -1c
.RI "void \fBMTZ_model\fP (\fBinstance\fP *problem)"
.br
.RI "Solve with 'Sequential Formulation' model by Miller, Tucker and Zemlin (1960)\&. "
.ti -1c
.RI "void \fBFlow1_model\fP (\fBinstance\fP *problem)"
.br
.RI "Solve with 'Single Commodity Flow' model by Gavish and Graves (1978)\&. "
.ti -1c
.RI "void \fBLazyMTZ_model\fP (\fBinstance\fP *problem)"
.br
.RI "Solve with 'Sequential Formulation' model with lazy constraints\&. "
.ti -1c
.RI "void \fBLazyFlow1_model\fP (\fBinstance\fP *problem)"
.br
.RI "Solve with 'Single Commodity Flow' model with lazy constraints\&. "
.ti -1c
.RI "void \fBLoop_model\fP (\fBinstance\fP *problem)"
.br
.RI "Branch and Cut model with SEC added at every restart\&. "
.ti -1c
.RI "void \fBLoopF_model\fP (\fBinstance\fP *problem)"
.br
.RI "Variant F of Loop model\&. "
.ti -1c
.RI "void \fBLoopM_model\fP (\fBinstance\fP *problem)"
.br
.RI "Variant M of Loop model\&. "
.ti -1c
.RI "void \fBLoopX_model\fP (\fBinstance\fP *problem)"
.br
.RI "Variant X of Loop model\&. "
.ti -1c
.RI "void \fBLegacy_model\fP (\fBinstance\fP *problem)"
.br
.RI "Branch and Cut model with legacy lazy cut callback\&. "
.ti -1c
.RI "void \fBGeneric_model\fP (\fBinstance\fP *problem)"
.br
.RI "Branch and Cut model with generic candidate cut callback\&. "
.ti -1c
.RI "void \fBLegacyConcorde_model\fP (\fBinstance\fP *problem)"
.br
.RI "Like Legacy, but also cuts the relaxation using Concorde routines\&. "
.ti -1c
.RI "void \fBGenericConcorde_model\fP (\fBinstance\fP *problem)"
.br
.RI "Like Generic, but also cuts the relaxation using Concorde routines\&. "
.ti -1c
.RI "void \fBLegacyConcordeShallow_model\fP (\fBinstance\fP *problem)"
.br
.RI "Like LegacyConcorde but only cuts nodes close to the root\&. "
.ti -1c
.RI "void \fBGenericConcordeShallow_model\fP (\fBinstance\fP *problem)"
.br
.RI "Like GenericConcorde but only cuts nodes close to the root\&. "
.ti -1c
.RI "void \fBLegacyConcordeRand_model\fP (\fBinstance\fP *problem)"
.br
.RI "Like LegacyConcorde but only cuts nodes with decreasing probability\&. "
.ti -1c
.RI "void \fBGenericConcordeRand_model\fP (\fBinstance\fP *problem)"
.br
.RI "Like GenericConcorde but only cuts nodes with decreasing probability\&. "
.ti -1c
.RI "void \fBGenericConcordeRandWithPatching_model\fP (\fBinstance\fP *problem)"
.br
.RI "Like GenericConcordeRand but provides CPLEX with heuristic solutions obtained with the Patching method\&. "
.ti -1c
.RI "void \fBHeurHardfix_model\fP (\fBinstance\fP *problem)"
.br
.RI "Solve with Hardfix heuristic\&. "
.ti -1c
.RI "void \fBHeurLocalBranching_model\fP (\fBinstance\fP *problem)"
.br
.RI "Solve with Local Branching heuristic\&. "
.ti -1c
.RI "void \fBHeurNearestNeighbor_model\fP (\fBinstance\fP *problem)"
.br
.RI "Solve with Nearest Neighbor heuristic\&. "
.ti -1c
.RI "void \fBHeurGRASP_model\fP (\fBinstance\fP *problem)"
.br
.RI "Solve with GRASP heuristic\&. "
.ti -1c
.RI "void \fBHeurInsertion_model\fP (\fBinstance\fP *problem)"
.br
.RI "Solve with Insertion heuristic\&. "
.ti -1c
.RI "void \fBHeurConvHullInsertion_model\fP (\fBinstance\fP *problem)"
.br
.RI "Solve with Convex Hull Insertion heuristic\&. "
.ti -1c
.RI "void \fBHeurGRASPWith2OPTRefinement_model\fP (\fBinstance\fP *problem)"
.br
.RI "GRASP heuristic method with 2-OPT refinement method\&. "
.ti -1c
.RI "void \fBHeurTabuSearch_model\fP (\fBinstance\fP *problem)"
.br
.RI "Tabu Search starting from a refined GRASP solution\&. "
.ti -1c
.RI "void \fBHeurVNS_model\fP (\fBinstance\fP *problem)"
.br
.RI "VNS heuristic method\&. "
.ti -1c
.RI "void \fBHeurSimulatedAnnealing_model\fP (\fBinstance\fP *problem)"
.br
.RI "Repeatedly run Simulated Annealing\&. "
.ti -1c
.RI "void \fBHeurGenetic_model\fP (\fBinstance\fP *problem)"
.br
.RI "Genetic Algorithm method\&. "
.in -1c
.SH "Detailed Description"
.PP 
Methods for solving a TSP problem\&. 


.PP
\fBAuthors:\fP
.RS 4
Francesco Cazzaro, Marco Cieno 
.RE
.PP

.SH "Macro Definition Documentation"
.PP 
.SS "#define TSP_SOLVER_Dummy   2U"
Dummy model\&. 
.SS "#define TSP_SOLVER_Flow1   4U"
Single Commodity Flow model (Gavish and Graves (1978))\&. 
.SS "#define TSP_SOLVER_Generic   12U"
Branch and Cut model with generic candidate cut callback\&. 
.SS "#define TSP_SOLVER_GenericConcorde   14U"
Like Generic, but also cuts the relaxation using Concorde routines\&. 
.SS "#define TSP_SOLVER_GenericConcordeRand   18U"
Like GenericConcorde but only cuts nodes with decreasing probability\&. 
.SS "#define TSP_SOLVER_GenericConcordeRandWithPatching   19U"
Like GenericConcordeRand but provides CPLEX with heuristic solutions obtained with the Patching method\&. 
.SS "#define TSP_SOLVER_GenericConcordeShallow   16U"
Like GenericConcorde but only cuts nodes close to the root\&. 
.SS "#define TSP_SOLVER_HeurConvHullInsertion   25U"
Convex Hull Insertion Heuristic\&. 
.SS "#define TSP_SOLVER_HeurGenetic   30U"
Genetic Algorithm\&. 
.SS "#define TSP_SOLVER_HeurGRASP   23U"
GRASP Heuristic\&. 
.SS "#define TSP_SOLVER_HeurGRASPWith2OPTRefinement   26U"
GRASP heuristic method with 2-OPT refinement method\&. 
.SS "#define TSP_SOLVER_HeurHardfix   20U"
Hardfix Heuristic\&. 
.SS "#define TSP_SOLVER_HeurInsertion   24U"
Insertion Heuristic\&. 
.SS "#define TSP_SOLVER_HeurLocalBranching   21U"
LocalBranching Heuristic\&. 
.SS "#define TSP_SOLVER_HeurNearestNeighbor   22U"
Nearest Neighbor Heuristic\&. 
.SS "#define TSP_SOLVER_HeurSimulatedAnnealing   29U"
Repeatedly run Simulated Annealing\&. 
.SS "#define TSP_SOLVER_HeurTabuSearch   28U"
Tabu Search on starting from a refined GRASP solution\&. 
.SS "#define TSP_SOLVER_HeurVNS   27U"
VNS heuristic method\&. 
.SS "#define TSP_SOLVER_LazyFlow1   6U"
Single Commodity Flow model with lazy constraints\&. 
.SS "#define TSP_SOLVER_LazyMTZ   5U"
Sequential Formulation model with lazy constraints\&. 
.SS "#define TSP_SOLVER_Legacy   11U"
Branch and Cut model with legacy lazy cut callback\&. 
.SS "#define TSP_SOLVER_LegacyConcorde   13U"
Like Legacy, but also cuts the relaxation using Concorde routines\&. 
.SS "#define TSP_SOLVER_LegacyConcordeRand   17U"
Like LegacyConcorde but only cuts nodes with decreasing probability\&. 
.SS "#define TSP_SOLVER_LegacyConcordeShallow   15U"
Like LegacyConcorde but only cuts nodes close to the root\&. 
.SS "#define TSP_SOLVER_Loop   7U"
Branch and Cut model with SEC added at every restart\&. 
.SS "#define TSP_SOLVER_LoopF   8U"
Variant F of Loop model\&. 
.SS "#define TSP_SOLVER_LoopM   9U"
Variant M of Loop model\&. 
.SS "#define TSP_SOLVER_LoopX   10U"
Variant X of Loop model\&. 
.SS "#define TSP_SOLVER_MTZ   3U"
Sequential Formulation model (Miller, Tucker and Zemlin (1960))\&. 
.SS "#define TSP_SOLVER_Random   1U"
Random model\&. 
.SH "Function Documentation"
.PP 
.SS "void _xopt2solution (const double * xopt, \fBinstance\fP * problem, size_t(*)(size_t, size_t, const \fBinstance\fP *) pos)"

.PP
Retrieve the solution after CPXmimopt was run\&. 
.PP
\fBParameters:\fP
.RS 4
\fIxopt\fP CPLEX incumbent solution\&.
.br
\fIproblem\fP Pointer to the instance structure
.br
\fIpos\fP Pointer to a function that given coordinates \fCi\fP and \fCj\fP returns the position in \fCxopt\fP fo \fCx(i,j)\fP\&. 
.RE
.PP

.SS "void _xopt2subtours (const \fBinstance\fP * problem, const double * xopt, size_t * next, size_t * comps, size_t * ncomps, size_t(*)(size_t, size_t, const \fBinstance\fP *) pos)"

.PP
Given a CPLEX-generated solution, create a more convenient representation\&. Given the incumbent solution \fCxopt\fP, where \fCxopt[e] = 1 <==> edge e was selected\fP, populate provided arrays \fCnext\fP and \fCcomps\fP so that \fCnext[i] = j <==> the tour goes from node i to node j\fP and \fCcomps[i] = k <==> node i is part of the k-th subtour\fP\&.
.PP
The number of subtours is written to \fCncomps\fP, hence \fCxopt\fP is a valid TSP solution iff \fCncomps == 1\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&.
.br
\fIxopt\fP CPLEX incumbent solution\&. \fCxstar[xpos(i, j)] == 1\fP iff the edge was selected\&.
.br
\fInext\fP Array of adjacencies to be filled\&. \fCnext[i] = j\fP means that there is an arc going from node \fCi\fP to node \fCj\fP\&.
.br
\fIcomps\fP Array of components indices to be filled\&. \fCcomps[i] = k\fP means that node \fCi\fP belongs to connected component \fCk\fP\&.
.br
\fIncomps\fP Pointer to an integer where to store the number of connected components in the solution\&. If 1, the solution is a tour\&.
.br
\fIpos\fP Pointer to a function that given coordinates \fCi\fP and \fCj\fP returns the position in \fCxopt\fP fo \fCx(i,j)\fP\&. 
.RE
.PP

.SS "void Dummy_model (\fBinstance\fP * problem)"

.PP
Solve with degree constraints-only model\&. 
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&.
.RE
.PP
\fBNote:\fP
.RS 4
This method does not include subtour elimination constraints\&. 
.RE
.PP

.SS "void Flow1_model (\fBinstance\fP * problem)"

.PP
Solve with 'Single Commodity Flow' model by Gavish and Graves (1978)\&. 
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void Generic_model (\fBinstance\fP * problem)"

.PP
Branch and Cut model with generic candidate cut callback\&. 
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void GenericConcorde_model (\fBinstance\fP * problem)"

.PP
Like Generic, but also cuts the relaxation using Concorde routines\&. This model uses Concorde to find cuts based on max-flow\&.
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void GenericConcordeRand_model (\fBinstance\fP * problem)"

.PP
Like GenericConcorde but only cuts nodes with decreasing probability\&. 
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void GenericConcordeRandWithPatching_model (\fBinstance\fP * problem)"

.PP
Like GenericConcordeRand but provides CPLEX with heuristic solutions obtained with the Patching method\&. 
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void GenericConcordeShallow_model (\fBinstance\fP * problem)"

.PP
Like GenericConcorde but only cuts nodes close to the root\&. 
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void HeurConvHullInsertion_model (\fBinstance\fP * problem)"

.PP
Solve with Convex Hull Insertion heuristic\&. This model uses the convex hull insertion method to find an heuristic solution\&.
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void HeurGenetic_model (\fBinstance\fP * problem)"

.PP
Genetic Algorithm method\&. This model applies a genetic algorithm to TSP\&.
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void HeurGRASP_model (\fBinstance\fP * problem)"

.PP
Solve with GRASP heuristic\&. Similar to Nearest Neighbor, but choses the nearest with probability 1/4, the second-nearest with probability 1/16, the third with 1/64 and so on\&.
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void HeurGRASPWith2OPTRefinement_model (\fBinstance\fP * problem)"

.PP
GRASP heuristic method with 2-OPT refinement method\&. This model applies the 2-OPT refinement method to every solution found with the GRASP heuristic\&.
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void HeurHardfix_model (\fBinstance\fP * problem)"

.PP
Solve with Hardfix heuristic\&. This model uses the hard-fixing technique to find an heuristic solution\&.
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void HeurInsertion_model (\fBinstance\fP * problem)"

.PP
Solve with Insertion heuristic\&. This model uses the insertion method to find an heuristic solution\&.
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void HeurLocalBranching_model (\fBinstance\fP * problem)"

.PP
Solve with Local Branching heuristic\&. This model uses the Local Branching for soft-fixing variables and find an heuristic solution\&.
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void HeurNearestNeighbor_model (\fBinstance\fP * problem)"

.PP
Solve with Nearest Neighbor heuristic\&. This model repeatedly applies the Nearest Neighbor heuristic starting from various nodes and accumulating the best solution\&.
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void HeurSimulatedAnnealing_model (\fBinstance\fP * problem)"

.PP
Repeatedly run Simulated Annealing\&. This model runs a simulated annealing multiple times and accumulates the best solution it finds during the iterations\&.
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void HeurTabuSearch_model (\fBinstance\fP * problem)"

.PP
Tabu Search starting from a refined GRASP solution\&. This model applies the Tabu Search metaheuristc technique for locally improving a GRASP solution\&. It uses 2-OPT moves for moving around the neighborhood of the current solution\&.
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void HeurVNS_model (\fBinstance\fP * problem)"

.PP
VNS heuristic method\&. This model applies the VNS heuristic\&.
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void LazyFlow1_model (\fBinstance\fP * problem)"

.PP
Solve with 'Single Commodity Flow' model with lazy constraints\&. 
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void LazyMTZ_model (\fBinstance\fP * problem)"

.PP
Solve with 'Sequential Formulation' model with lazy constraints\&. 
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void Legacy_model (\fBinstance\fP * problem)"

.PP
Branch and Cut model with legacy lazy cut callback\&. 
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void LegacyConcorde_model (\fBinstance\fP * problem)"

.PP
Like Legacy, but also cuts the relaxation using Concorde routines\&. This model uses Concorde to find cuts based on max-flow
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void LegacyConcordeRand_model (\fBinstance\fP * problem)"

.PP
Like LegacyConcorde but only cuts nodes with decreasing probability\&. 
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void LegacyConcordeShallow_model (\fBinstance\fP * problem)"

.PP
Like LegacyConcorde but only cuts nodes close to the root\&. 
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void Loop_model (\fBinstance\fP * problem)"

.PP
Branch and Cut model with SEC added at every restart\&. 
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void LoopF_model (\fBinstance\fP * problem)"

.PP
Variant F of Loop model\&. This model is similar to \fBLoop_model()\fP\&. The main difference is that it starts with a loose EPGAP and tightens it iteration after iteration, until a single component is found, possibly sub-optimal\&. At that point, the default MIP optimizer is run\&.
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void LoopM_model (\fBinstance\fP * problem)"

.PP
Variant M of Loop model\&. This model is similar to \fBLoop_model()\fP\&. The main difference is that it starts with a loose EPGAP and a small limit of solutions\&. It tightens the gap and increases the solution limit until a single component is found, possibly sub-optimal\&. At that point, the default MIP optimizer is run\&.
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void LoopX_model (\fBinstance\fP * problem)"

.PP
Variant X of Loop model\&. This model is similar to \fBLoop_model()\fP\&. The main difference is that it starts with a tight EPGAP and a large limit of solutions\&. It looses them according to the number of components it found at each solution, until a single component is found, possibly sub-optimal\&. At that point, the default MIP optimizer is run\&.
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void MTZ_model (\fBinstance\fP * problem)"

.PP
Solve with 'Sequential Formulation' model by Miller, Tucker and Zemlin (1960)\&. 
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void Random_model (\fBinstance\fP * problem)"

.PP
Generate a Random solution for the instance\&. 
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for TSP Solver from the source code\&.

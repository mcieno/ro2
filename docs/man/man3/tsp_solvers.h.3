.TH "include/tsp_solvers.h" 3 "Fri Apr 24 2020" "TSP Solver" \" -*- nroff -*-
.ad l
.nh
.SH NAME
include/tsp_solvers.h \- Methods for solving a TSP problem\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <cplex\&.h>\fP
.br
\fC#include 'tsp\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBTSP_SOLVER_Random\fP   1U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_Dummy\fP   2U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_MTZ\fP   3U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_Flow1\fP   4U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_LazyMTZ\fP   5U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_LazyFlow1\fP   6U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_Loop\fP   7U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_LoopF\fP   8U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_LoopM\fP   9U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_LoopX\fP   10U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_Legacy\fP   11U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_Generic\fP   12U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_LegacyConcorde\fP   13U"
.br
.ti -1c
.RI "#define \fBTSP_SOLVER_GenericConcorde\fP   14U"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef unsigned \fBmodel_t\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fB_xopt2solution\fP (const double *xopt, \fBinstance\fP *problem, size_t(*pos)(size_t, size_t, const \fBinstance\fP *))"
.br
.RI "Retrieve the solution after CPXmimopt was run\&. "
.ti -1c
.RI "void \fB_xopt2subtours\fP (const \fBinstance\fP *problem, const double *xopt, size_t *next, size_t *comps, size_t *ncomps, size_t(*pos)(size_t, size_t, const \fBinstance\fP *))"
.br
.RI "Given a CPLEX-generated solution, create a more convenient representation\&. "
.ti -1c
.RI "void \fBRandom_model\fP (\fBinstance\fP *problem)"
.br
.RI "Generate a Random solution for the instance\&. "
.ti -1c
.RI "void \fBDummy_model\fP (\fBinstance\fP *problem)"
.br
.RI "Solve with degree constraints-only model\&. "
.ti -1c
.RI "void \fBMTZ_model\fP (\fBinstance\fP *problem)"
.br
.RI "Solve with 'Sequential Formulation' model by Miller, Tucker and Zemlin (1960)\&. "
.ti -1c
.RI "void \fBFlow1_model\fP (\fBinstance\fP *problem)"
.br
.RI "Solve with 'Single Commodity Flow' model by Gavish and Graves (1978)\&. "
.ti -1c
.RI "void \fBLazyMTZ_model\fP (\fBinstance\fP *problem)"
.br
.RI "Solve with 'Sequential Formulation' model with lazy constraints\&. "
.ti -1c
.RI "void \fBLazyFlow1_model\fP (\fBinstance\fP *problem)"
.br
.RI "Solve with 'Single Commodity Flow' model with lazy constraints\&. "
.ti -1c
.RI "void \fBLoop_model\fP (\fBinstance\fP *problem)"
.br
.RI "Solve with Dummy 'Branch and Cut' model, restarting cplex after every intermediate solution\&. "
.ti -1c
.RI "void \fBLoopF_model\fP (\fBinstance\fP *problem)"
.br
.RI "Solve with Dummy 'Branch and Cut' model (variant 'F'), restarting cplex after every intermediate solution\&. "
.ti -1c
.RI "void \fBLoopM_model\fP (\fBinstance\fP *problem)"
.br
.RI "Solve with Dummy 'Branch and Cut' model (variant 'M'), restarting cplex after every intermediate solution\&. "
.ti -1c
.RI "void \fBLoopX_model\fP (\fBinstance\fP *problem)"
.br
.RI "Solve with Dummy 'Branch and Cut' model (variant 'X'), restarting cplex after every intermediate solution\&. "
.ti -1c
.RI "void \fBLegacy_model\fP (\fBinstance\fP *problem)"
.br
.RI "Solve with 'Branch and Cut' model with lazy constraint callback\&. "
.ti -1c
.RI "void \fBGeneric_model\fP (\fBinstance\fP *problem)"
.br
.RI "Solve with 'Branch and Cut' model with lazy constraint generic callback\&. "
.ti -1c
.RI "void \fBLegacyConcorde_model\fP (\fBinstance\fP *problem)"
.br
.RI "Solve with 'Branch and Cut' model with lazy constraint callback and Concorde user cuts\&. "
.ti -1c
.RI "void \fBGenericConcorde_model\fP (\fBinstance\fP *problem)"
.br
.RI "Solve with 'Branch and Cut' model with lazy constraint generic callback and Concorde user cuts\&. "
.in -1c
.SH "Detailed Description"
.PP 
Methods for solving a TSP problem\&. 


.PP
\fBAuthors:\fP
.RS 4
Francesco Cazzaro, Marco Cieno 
.RE
.PP

.SH "Macro Definition Documentation"
.PP 
.SS "#define TSP_SOLVER_Dummy   2U"
Dummy model\&. 
.SS "#define TSP_SOLVER_Flow1   4U"
Single Commodity Flow model (Gavish and Graves (1978))\&. 
.SS "#define TSP_SOLVER_Generic   12U"
Branch and Cut model with generic callback\&. 
.SS "#define TSP_SOLVER_GenericConcorde   14U"
Branch and Cut model with Concorde with generic callback\&. 
.SS "#define TSP_SOLVER_LazyFlow1   6U"
Single Commodity Flow model with lazy constraints\&. 
.SS "#define TSP_SOLVER_LazyMTZ   5U"
Sequential Formulation model with lazy constraints\&. 
.SS "#define TSP_SOLVER_Legacy   11U"
Branch and Cut model with lazy constraint callback\&. 
.SS "#define TSP_SOLVER_LegacyConcorde   13U"
Branch and Cut model with Concorde callback\&. 
.SS "#define TSP_SOLVER_Loop   7U"
Loop Branch and Cut model\&. 
.SS "#define TSP_SOLVER_LoopF   8U"
Variant F of the loop Branch and Cut model\&. 
.SS "#define TSP_SOLVER_LoopM   9U"
Variant M of the loop Branch and Cut model\&. 
.SS "#define TSP_SOLVER_LoopX   10U"
Variant X of the loop Branch and Cut model\&. 
.SS "#define TSP_SOLVER_MTZ   3U"
Sequential Formulation model (Miller, Tucker and Zemlin (1960))\&. 
.SS "#define TSP_SOLVER_Random   1U"
Random model\&. 
.SH "Function Documentation"
.PP 
.SS "void _xopt2solution (const double * xopt, \fBinstance\fP * problem, size_t(*)(size_t, size_t, const \fBinstance\fP *) pos)"

.PP
Retrieve the solution after CPXmimopt was run\&. 
.PP
\fBParameters:\fP
.RS 4
\fIxopt\fP CPLEX incumbent solution\&.
.br
\fIproblem\fP Pointer to the instance structure
.br
\fIpos\fP Pointer to a function that given coordinates \fCi\fP and \fCj\fP returns the position in \fCxopt\fP fo \fCx(i,j)\fP\&. 
.RE
.PP

.SS "void _xopt2subtours (const \fBinstance\fP * problem, const double * xopt, size_t * next, size_t * comps, size_t * ncomps, size_t(*)(size_t, size_t, const \fBinstance\fP *) pos)"

.PP
Given a CPLEX-generated solution, create a more convenient representation\&. Given the incumbent solution \fCxopt\fP, where \fCxopt[e] = 1 <==> edge e was selected\fP, populate provided arrays \fCnext\fP and \fCcomps\fP so that \fCnext[i] = j <==> the tour goes from node i to node j\fP and \fCcomps[i] = k <==> node i is part of the k-th subtour\fP\&.
.PP
The number of subtours is written to \fCncomps\fP, hence \fCxopt\fP is a valid TSP solution iff \fCncomps == 1\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&.
.br
\fIxopt\fP CPLEX incumbent solution\&. \fCxstar[xpos(i, j)] == 1\fP iff the edge was selected\&.
.br
\fInext\fP Array of adjacencies to be filled\&. \fCnext[i] = j\fP means that there is an arc going from node \fCi\fP to node \fCj\fP\&.
.br
\fIcomps\fP Array of components indices to be filled\&. \fCcomps[i] = k\fP means that node \fCi\fP belongs to connected component \fCk\fP\&.
.br
\fIncomps\fP Pointer to an integer where to store the number of connected components in the solution\&. If 1, the solution is a tour\&.
.br
\fIpos\fP Pointer to a function that given coordinates \fCi\fP and \fCj\fP returns the position in \fCxopt\fP fo \fCx(i,j)\fP\&. 
.RE
.PP

.SS "void Dummy_model (\fBinstance\fP * problem)"

.PP
Solve with degree constraints-only model\&. 
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&.
.RE
.PP
\fBNote:\fP
.RS 4
This method does not include subtour elimination constraints\&. 
.RE
.PP

.SS "void Flow1_model (\fBinstance\fP * problem)"

.PP
Solve with 'Single Commodity Flow' model by Gavish and Graves (1978)\&. 
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void Generic_model (\fBinstance\fP * problem)"

.PP
Solve with 'Branch and Cut' model with lazy constraint generic callback\&. 
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void GenericConcorde_model (\fBinstance\fP * problem)"

.PP
Solve with 'Branch and Cut' model with lazy constraint generic callback and Concorde user cuts\&. This model uses Concorde to find cuts based on max-flow
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void LazyFlow1_model (\fBinstance\fP * problem)"

.PP
Solve with 'Single Commodity Flow' model with lazy constraints\&. 
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void LazyMTZ_model (\fBinstance\fP * problem)"

.PP
Solve with 'Sequential Formulation' model with lazy constraints\&. 
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void Legacy_model (\fBinstance\fP * problem)"

.PP
Solve with 'Branch and Cut' model with lazy constraint callback\&. 
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void LegacyConcorde_model (\fBinstance\fP * problem)"

.PP
Solve with 'Branch and Cut' model with lazy constraint callback and Concorde user cuts\&. This model uses Concorde to find cuts based on max-flow
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void Loop_model (\fBinstance\fP * problem)"

.PP
Solve with Dummy 'Branch and Cut' model, restarting cplex after every intermediate solution\&. 
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void LoopF_model (\fBinstance\fP * problem)"

.PP
Solve with Dummy 'Branch and Cut' model (variant 'F'), restarting cplex after every intermediate solution\&. This model is similar to \fBLoop_model()\fP\&. The main difference is that it starts with a loose EPGAP and tightens it iteration after iteration, until a single component is found, possibly sub-optimal\&. At that point, the default MIP optimizer is run\&.
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void LoopM_model (\fBinstance\fP * problem)"

.PP
Solve with Dummy 'Branch and Cut' model (variant 'M'), restarting cplex after every intermediate solution\&. This model is similar to \fBLoop_model()\fP\&. The main difference is that it starts with a loose EPGAP and a small limit of solutions\&. It tightens the gap and increases the solution limit until a single component is found, possibly sub-optimal\&. At that point, the default MIP optimizer is run\&.
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void LoopX_model (\fBinstance\fP * problem)"

.PP
Solve with Dummy 'Branch and Cut' model (variant 'X'), restarting cplex after every intermediate solution\&. This model is similar to \fBLoop_model()\fP\&. The main difference is that it starts with a tight EPGAP and a large limit of solutions\&. It looses them according to the number of components it found at each solution, until a single component is found, possibly sub-optimal\&. At that point, the default MIP optimizer is run\&.
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void MTZ_model (\fBinstance\fP * problem)"

.PP
Solve with 'Sequential Formulation' model by Miller, Tucker and Zemlin (1960)\&. 
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SS "void Random_model (\fBinstance\fP * problem)"

.PP
Generate a Random solution for the instance\&. 
.PP
\fBParameters:\fP
.RS 4
\fIproblem\fP Pointer to the instance structure\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for TSP Solver from the source code\&.
